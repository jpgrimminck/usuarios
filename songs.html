<html><head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<link crossorigin="" href="https://fonts.gstatic.com/" rel="preconnect"/>
<link as="style" href="https://fonts.googleapis.com/css2?display=swap&amp;family=Inter%3Awght%40400%3B500%3B700%3B900&amp;family=Noto+Sans%3Awght%40400%3B500%3B700%3B900" onload="this.rel='stylesheet'" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet"/>
<title>Stitch Design</title>
<link href="data:image/x-icon;base64," rel="icon" type="image/x-icon"/>
<link rel="stylesheet" href="styles.css"/>
<style>
      :root {
        --primary-color: #137fec;
      }
      body {
        font-family: 'Inter', sans-serif;
      }
    </style>
<style>
    body {
      min-height: max(884px, 100dvh);
    }
  </style>
<style>
    body {
      min-height: max(884px, 100dvh);
    }
  </style>
  </head>
<body class="bg-gray-900">
<div class="relative flex size-full min-h-screen flex-col justify-between group/design-root overflow-x-hidden text-white">
  <!-- Header: keep separate from scrollable area -->
  <div id="site-header" class="bg-gray-900/95 backdrop-blur-sm" style="position: fixed; top: 0; left: 0; right: 0; height: 40px; z-index: 30;">
    <div class="flex items-center p-4 pb-2 justify-between">
      <div class="w-12 flex items-center">
        <button id="back-button" aria-label="Volver" class="flex items-center justify-center rounded-full h-10 w-10 text-white hover:bg-white/10 transition-colors">
          <span class="material-symbols-outlined text-2xl">arrow_back</span>
        </button>
      </div>
      <h1 class="text-xl font-bold leading-tight tracking-tight flex-1 text-center">Canciones</h1>
      <div class="flex w-12 items-center justify-end">
        <button class="flex items-center justify-center rounded-full h-10 w-10 text-white hover:bg-white/10 transition-colors">
          <span class="material-symbols-outlined text-2xl">add</span>
        </button>
      </div>
    </div>
  </div>

  <!-- Scrollable list area separated from header -->
  <div id="songs-scroll" class="flex-1 overflow-y-auto" style="padding-top: 80px;">
    <div id="songs-container" class="flex flex-col songs-list">
      <!-- cards will be injected here -->
    </div>
  </div>
  <button id="add-song-fab" class="fixed bg-blue-500 hover:bg-blue-700 text-white rounded-full flex items-center justify-center" style="bottom:24px; right:24px; width:56px; height:56px; z-index:25;">
    <span class="material-symbols-outlined text-3xl">add</span>
  </button>
  <div id="add-song-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden" style="z-index:30;">
    <div class="bg-gray-800 p-6 rounded-lg text-white w-full" style="max-width:350px; position:relative;">
      <h2 class="text-xl font-bold" style="margin:0 0 16px 0; text-align:center;">Agregar canción</h2>
      <div class="suggested-wrapper">
        <div id="suggested-songs-container" class="suggested-grid"></div>
      </div>
      <div class="suggested-actions">
        <button type="button" id="add-selected-songs" class="suggested-primary" disabled>Añadir a mi lista</button>
      </div>
    </div>
  </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="config.js"></script>
<script>
const supabase = window.supabase.createClient(window.SUPABASE_URL, window.SUPABASE_ANON_KEY);
const urlParams = new URLSearchParams(window.location.search);
const selectedUserId = urlParams.get('id');
let songsRefreshTimeoutId = null;
const sampleSongs = [
  { title: 'Sol de Medianoche', artist: 'Luna Áurea' },
  { title: 'Viento del Sur', artist: 'Horizonte Azul' },
  { title: 'Caminos de Sal', artist: 'Los Errantes' },
  { title: 'Corazón Mapache', artist: 'Selva Lenta' },
  { title: 'Pasos de Fuego', artist: 'Bruma Roja' },
  { title: 'Nubes de Abril', artist: 'Camila Rivero' },
  { title: 'Tiempo en Re', artist: 'Los Forasteros' },
  { title: 'Mar Adentro', artist: 'Nora Esencial' },
  { title: 'Río Eléctrico', artist: 'Voltaje 21' },
  { title: 'Bosque de Cristal', artist: 'Dalia Boreal' },
  { title: 'Horizonte Ígneo', artist: 'Alma Bravía' },
  { title: 'Flor de Cardo', artist: 'Lucía y el Monte' },
  { title: 'Sueño de Plata', artist: 'Sirenas del Sur' },
  { title: 'Puesta Morena', artist: 'Ecos Urbanos' },
  { title: 'Ritmo Lunar', artist: 'Trío Eclipse' },
  { title: 'Luz en la Niebla', artist: 'Matías Prado' },
  { title: 'Nave de Papel', artist: 'Cielo Frágil' },
  { title: 'Verde Azahar', artist: 'Estación Primavera' },
  { title: 'Faro del Alma', artist: 'Lucero Atlántico' },
  { title: 'Espinas y Rosas', artist: 'Marina Oscura' },
  { title: 'Fuga del Sol', artist: 'Ráfaga Dorada' },
  { title: 'Zarpazo', artist: 'Los Felinos' },
  { title: 'Lluvia de Agosto', artist: 'Paula Méndez' },
  { title: 'Cicatriz de Luz', artist: 'Ave Nómada' },
  { title: 'Frontera Nítida', artist: 'La Ruta Blanca' },
  { title: 'Boreal', artist: 'Sofía Vega' },
  { title: 'Eco en la Arena', artist: 'Kilómetro Cero' },
  { title: 'Puerto Equinox', artist: 'Valiente Prisma' },
  { title: 'Latido Azul', artist: 'Domo Atlántida' },
  { title: 'Brisa Mística', artist: 'Isla Tiburón' }
];

const STATUS_CYCLE = ['Not started', 'Practicing', 'Completed'];
const DEFAULT_STATUS = STATUS_CYCLE[0];
const selectedLibrarySongs = new Map();

function normalizeStatusTag(value) {
  return (value || '').toLowerCase().replace(/\s+/g, '-');
}

function getNextStatusTag(currentStatus) {
  const index = STATUS_CYCLE.indexOf(currentStatus);
  if (index === -1 || index === STATUS_CYCLE.length - 1) {
    return STATUS_CYCLE[0];
  }
  return STATUS_CYCLE[index + 1];
}

function applyStatusStyles(button, statusTag) {
  if (!button) return;
  const resolvedStatus = STATUS_CYCLE.includes(statusTag) ? statusTag : DEFAULT_STATUS;
  const normalized = normalizeStatusTag(resolvedStatus);
  button.textContent = resolvedStatus;
  button.dataset.status = resolvedStatus;
  STATUS_CYCLE.forEach(state => {
    button.classList.remove(`song-status-button--${normalizeStatusTag(state)}`);
  });
  button.classList.add(`song-status-button--${normalized}`);
}

async function persistStatusTag(songId, nextStatus) {
  const query = supabase
    .from('user_songs')
    .update({ status_tag: nextStatus })
    .eq('user_id', selectedUserId)
    .eq('song_id', songId)
    .select('song_id, status_tag')
    .maybeSingle();

  const { data, error } = await query;
  if (error) {
    throw error;
  }
  if (!data) {
    throw new Error('No matching user_songs row was updated.');
  }
  return data.status_tag || nextStatus;
}

async function updateSongsTitle() {
  const titleEl = document.querySelector('#site-header h1');
  if (!titleEl) return;
  if (!selectedUserId) {
    titleEl.textContent = 'Canciones';
    return;
  }
  try {
    const { data, error } = await supabase
      .from('users')
      .select('name')
      .eq('id', selectedUserId)
      .single();
    if (!error && data && data.name) {
      titleEl.textContent = `Canciones de ${data.name}`;
    } else {
      titleEl.textContent = 'Canciones';
    }
  } catch (err) {
    console.warn('No se pudo obtener el nombre del usuario para el título:', err);
    titleEl.textContent = 'Canciones';
  }
}

// Ensure the songs container has top padding equal to header height to avoid overlap.
function adjustSongsContainerPadding() {
  const header = document.getElementById('site-header');
  const container = document.getElementById('songs-container');
  if (!header || !container) return;
  const scrollWrapper = document.getElementById('songs-scroll');
  if (scrollWrapper) {
    scrollWrapper.style.visibility = 'hidden';
    requestAnimationFrame(() => { scrollWrapper.style.visibility = 'visible'; });
  }
  header.style.zIndex = 30;
}

function renderSuggestedSongs(onSelect) {
  const container = document.getElementById('suggested-songs-container');
  if (!container) return;
  container.innerHTML = '';
  const addButton = document.getElementById('add-selected-songs');
  if (addButton) {
    addButton.disabled = !selectedUserId || selectedLibrarySongs.size === 0;
  }
  // fallback to sampleSongs if no list provided
  const sourceSongs = renderSuggestedSongs._lastList || sampleSongs;
  const sortedSongs = [...sourceSongs].sort((a, b) => {
    const aTitle = (a.title || '').toString();
    const bTitle = (b.title || '').toString();
    return aTitle.localeCompare(bTitle, 'es', { sensitivity: 'base' });
  });

  sortedSongs.forEach((song) => {
    const card = document.createElement('div');
    card.className = 'suggested-card';

    const titleSpan = document.createElement('span');
    titleSpan.className = 'suggested-title';
    // support both sampleSongs shape ({title,artist}) and DB shape ({title, artists:{name}})
    const songTitle = song.title || '';
    titleSpan.textContent = songTitle;

    const artistSpan = document.createElement('span');
    artistSpan.className = 'suggested-artist';
    artistSpan.textContent = song.artist || song.artists?.name || '';

    const addButton = document.createElement('button');
    addButton.className = 'suggested-add';
    addButton.type = 'button';
    addButton.setAttribute('aria-pressed', 'false');
    addButton.innerHTML = '<span class="material-symbols-outlined">add</span>';

    const songId = song.id;
    const key = songId ?? songTitle;
    if (selectedLibrarySongs.has(key)) {
      addButton.classList.add('suggested-add--selected');
      addButton.setAttribute('aria-pressed', 'true');
      const iconSpanInit = addButton.querySelector('.material-symbols-outlined');
      if (iconSpanInit) iconSpanInit.textContent = 'check';
    }

    addButton.addEventListener('click', () => {
      const iconSpan = addButton.querySelector('.material-symbols-outlined');
      const existingTimeout = addButton.dataset.animTimeout;

      if (existingTimeout) {
        clearTimeout(Number(existingTimeout));
        delete addButton.dataset.animTimeout;
      }

          const wasSelected = addButton.classList.contains('suggested-add--selected');
      if (wasSelected) {
        addButton.classList.remove('suggested-add--selected', 'suggested-add--animating');
        addButton.setAttribute('aria-pressed', 'false');
        if (iconSpan) {
          iconSpan.textContent = 'add';
        }
        selectedLibrarySongs.delete(key);
        if (typeof onSelect === 'function') {
          onSelect(null);
        }
        const footerButton = document.getElementById('add-selected-songs');
        if (footerButton && !footerButton.dataset.working) {
          footerButton.disabled = selectedLibrarySongs.size === 0;
        }
        return;
      }

      addButton.classList.add('suggested-add--animating');
      addButton.setAttribute('aria-pressed', 'true');

      if (iconSpan) {
        iconSpan.textContent = 'check';
      }

      if (typeof onSelect === 'function') {
        onSelect(song);
      }

      selectedLibrarySongs.set(key, { id: songId, title: songTitle, artist: song.artist || song.artists?.name || '' });

      // Force the radial fill to begin immediately before locking the selected state
      void addButton.offsetWidth;
      addButton.classList.add('suggested-add--selected');

      const timeoutId = setTimeout(() => {
        addButton.classList.remove('suggested-add--animating');
        delete addButton.dataset.animTimeout;
      }, 320);

      addButton.dataset.animTimeout = String(timeoutId);

          const footerButton = document.getElementById('add-selected-songs');
          if (footerButton && !footerButton.dataset.working) {
            footerButton.disabled = selectedLibrarySongs.size === 0;
          }
    });

    card.appendChild(titleSpan);
    card.appendChild(artistSpan);
    card.appendChild(addButton);
    container.appendChild(card);
  });
}

// Fetch songs from the 'songs' table (library)
async function fetchLibrarySongs() {
  try {
    const { data, error } = await supabase
      .from('songs')
      .select(`id, title, artists ( name )`)
      .order('title', { ascending: true });
    if (error) {
      console.error('Error fetching library songs:', error);
      return [];
    }
    return data || [];
  } catch (err) {
    console.error('Unexpected error fetching library songs:', err);
    return [];
  }
}

function initAddSongModal() {
  const fab = document.getElementById('add-song-fab');
  const modal = document.getElementById('add-song-modal');
  const closeBtn = document.getElementById('add-song-close');

  if (!fab || !modal) return;

  const addSelectedButton = document.getElementById('add-selected-songs');

  const handleSuggestionSelect = (song) => {
    if (!song) return;
    console.log('Seleccionar canción sugerida:', song.title, '/', song.artist);
  };

  function openModal() {
    // Fetch library songs and render them in the modal
    fetchLibrarySongs().then(list => {
      renderSuggestedSongs._lastList = list.length ? list : sampleSongs;
      renderSuggestedSongs(handleSuggestionSelect);
    }).catch(() => {
      renderSuggestedSongs._lastList = sampleSongs;
      renderSuggestedSongs(handleSuggestionSelect);
    });
    if (addSelectedButton) {
      addSelectedButton.disabled = !selectedUserId || selectedLibrarySongs.size === 0;
    }
    modal.classList.remove('hidden');
  }

  function closeModal() {
    modal.classList.add('hidden');
    selectedLibrarySongs.clear();
    if (addSelectedButton) {
      addSelectedButton.disabled = true;
    }
  }

  fab.addEventListener('click', openModal);

  if (closeBtn) {
    closeBtn.addEventListener('click', closeModal);
  }

  modal.addEventListener('click', function (event) {
    if (event.target === modal) {
      closeModal();
    }
  });

  // Render initially so the modal is ready if opened via other triggers
  // prefetch library songs for faster open
  fetchLibrarySongs().then(list => {
    renderSuggestedSongs._lastList = list.length ? list : sampleSongs;
    renderSuggestedSongs(handleSuggestionSelect);
  }).catch(() => {
    renderSuggestedSongs._lastList = sampleSongs;
    renderSuggestedSongs(handleSuggestionSelect);
  });

  if (addSelectedButton) {
    addSelectedButton.addEventListener('click', async () => {
      if (!selectedUserId || selectedLibrarySongs.size === 0) {
        return;
      }
    addSelectedButton.disabled = true;
    addSelectedButton.dataset.working = 'true';
    addSelectedButton.textContent = 'Añadiendo...';

      try {
        const additions = Array.from(selectedLibrarySongs.values())
          .map(entry => entry?.id)
          .filter(id => id !== null && id !== undefined);

        if (!additions.length) {
          addSelectedButton.textContent = 'Añadir a mi lista';
          addSelectedButton.disabled = false;
          return;
        }

        const { data: existingRows, error: existingError } = await supabase
          .from('user_songs')
          .select('song_id')
          .eq('user_id', selectedUserId)
          .in('song_id', additions);

        if (existingError) {
          throw existingError;
        }

        const existingIds = new Set((existingRows || []).map(row => row.song_id));
        const insertPayload = additions
          .filter(songId => !existingIds.has(songId))
          .map(songId => ({ user_id: selectedUserId, song_id: songId, status_tag: DEFAULT_STATUS }));

        if (insertPayload.length) {
          const { error: insertError } = await supabase
            .from('user_songs')
            .insert(insertPayload);

          if (insertError) {
            throw insertError;
          }
        }

        selectedLibrarySongs.clear();
        await loadSongs();
        closeModal();
      } catch (err) {
        console.error('Error adding songs to list:', err);
      } finally {
        delete addSelectedButton.dataset.working;
        addSelectedButton.textContent = 'Añadir a mi lista';
        addSelectedButton.disabled = !selectedUserId || selectedLibrarySongs.size === 0;
      }
    });
  }
}

function scheduleSongsRefresh() {
  if (songsRefreshTimeoutId) {
    clearTimeout(songsRefreshTimeoutId);
  }
  songsRefreshTimeoutId = setTimeout(() => {
    songsRefreshTimeoutId = null;
    loadSongs();
  }, 150);
}

function initSongsRealtime() {
  const channel = supabase
    .channel('songs_realtime')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'canciones' }, scheduleSongsRefresh)
    .on('postgres_changes', { event: '*', schema: 'public', table: 'artists' }, scheduleSongsRefresh)
    .on('postgres_changes', { event: '*', schema: 'public', table: 'user_songs' }, scheduleSongsRefresh);

  channel.subscribe((status) => {
    if (status === 'CHANNEL_ERROR') {
      console.error('Error suscribiendo al canal de canciones en tiempo real');
    }
  });
}

// Run on load and when resizing
window.addEventListener('load', adjustSongsContainerPadding);
window.addEventListener('resize', adjustSongsContainerPadding);

async function loadSongs() {
  const container = document.getElementById('songs-container');
  if (!container) return;
  container.innerHTML = '';

  try {
    let songs = null;

    const statusBySongId = new Map();

    if (selectedUserId) {
      // 1) Get song IDs linked to this user from user_songs
      const { data: userSongs, error: usErr } = await supabase
        .from('user_songs')
        .select('song_id, status_tag')
        .eq('user_id', selectedUserId);

      if (usErr) {
        console.error('Error loading user_songs:', usErr);
        return;
      }

      const songIds = (userSongs || []).map(r => r.song_id).filter(Boolean);
      (userSongs || []).forEach(record => {
        if (!record || !record.song_id) return;
        statusBySongId.set(record.song_id, record.status_tag || DEFAULT_STATUS);
      });
      if (!songIds.length) {
        container.innerHTML = '<p class="text-gray-400 p-4">No hay canciones para este usuario.</p>';
        return;
      }

      // 2) Load only those canciones
      const { data, error } = await supabase
        .from('songs')
        .select(`
          id,
          title,
          artists ( name )
        `)
        .in('id', songIds);

      if (error) {
        console.error(error);
        return;
      }
      songs = data;
    } else {
      // No selected user: load all songs as before
      const { data, error } = await supabase
        .from('songs')
        .select(`
          id,
          title,
          artists ( name )
        `);
      if (error) {
        console.error(error);
        return;
      }
      songs = data;
    }

    // Render songs (same rendering logic as before)
    songs.forEach(song => {
      if (!song || !song.id) return;
      const songTitle = song.title;
      if (!songTitle) return;
      const artistName = song.artists?.name || '';
      const firstLetter = songTitle.charAt(0).toUpperCase();
      const songElement = document.createElement('a');
      const audioParams = new URLSearchParams({ songId: song.id, title: songTitle });
      if (selectedUserId) {
        audioParams.set('id', selectedUserId);
      }
  songElement.href = `audios/audios.html?${audioParams.toString()}`;
      songElement.className = 'song-card flex items-center gap-4 px-4 py-3 hover:bg-white/5 transition-colors duration-200';
      const statusTag = statusBySongId.get(song.id) || DEFAULT_STATUS;
      const statusClassSuffix = normalizeStatusTag(statusTag);
      const statusButtonHtml = selectedUserId
        ? `<button type="button" class="song-status-button song-status-button--${statusClassSuffix}" data-song-id="${song.id}" data-status="${statusTag}">${statusTag}</button>`
        : '';
      songElement.innerHTML = `
        <div class="bg-[var(--primary-color)] flex items-center justify-center text-white font-bold text-xl rounded-lg size-20">${firstLetter}</div>
        <div class="flex-1">
          <p class="text-white text-base font-medium leading-normal">${songTitle}</p>
          <p class="text-gray-400 text-sm font-normal leading-normal">${artistName}</p>
        </div>
        ${statusButtonHtml}
        <button class="flex items-center justify-center rounded-full h-10 w-10 text-gray-400 hover:text-white hover:bg-white/10 transition-colors">
          <span class="material-symbols-outlined">more_vert</span>
        </button>
      `;
      const statusButton = songElement.querySelector('.song-status-button');
      if (statusButton && selectedUserId) {
        applyStatusStyles(statusButton, statusTag);
        statusButton.addEventListener('click', async (event) => {
          event.preventDefault();
          event.stopPropagation();
          const currentStatus = statusButton.dataset.status || DEFAULT_STATUS;
          const nextStatus = getNextStatusTag(currentStatus);
          statusButton.disabled = true;
          applyStatusStyles(statusButton, nextStatus);
          try {
            const persistedStatus = await persistStatusTag(song.id, nextStatus);
            applyStatusStyles(statusButton, persistedStatus);
            statusBySongId.set(song.id, persistedStatus);
          } catch (err) {
            console.error('Error updating status_tag:', err);
            applyStatusStyles(statusButton, currentStatus);
          } finally {
            statusButton.disabled = false;
          }
        });
      }
      container.appendChild(songElement);
    });
  } catch (err) {
    console.error('Error in loadSongs:', err);
  }
}

loadSongs();
updateSongsTitle();
initAddSongModal();
initSongsRealtime();
</script>
<script>
// Back button behavior: try history.back(), fallback to index.html
document.addEventListener('DOMContentLoaded', function () {
  const backBtn = document.getElementById('back-button');
  if (!backBtn) return;
  backBtn.addEventListener('click', function (e) {
    e.preventDefault();
    // Always navigate back to index.html (preserve id if present) using replace
    const params = new URLSearchParams(window.location.search);
    const id = params.get('id');
    const target = id ? `index.html?id=${encodeURIComponent(id)}` : 'index.html';
    // Use replace so this navigation doesn't create a new history entry
    window.location.replace(target);
  });
});
</script>