<html><head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<link crossorigin="" href="https://fonts.gstatic.com/" rel="preconnect"/>
<link as="style" href="https://fonts.googleapis.com/css2?display=swap&amp;family=Inter%3Awght%40400%3B500%3B700%3B900&amp;family=Noto+Sans%3Awght%40400%3B500%3B700%3B900" onload="this.rel='stylesheet'" rel="preload"/>
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet"/>
<title>Stitch Design</title>
<link href="data:image/x-icon;base64," rel="icon" type="image/x-icon"/>
<link rel="stylesheet" href="styles.css"/>
<style>
      :root {
        --primary-color: #137fec;
      }
      .material-symbols-outlined {
        font-variation-settings:
        'FILL' 0,
        'wght' 400,
        'GRAD' 0,
        'opsz' 24
      }
    </style>
  <style>
    .audio-card {
      cursor: pointer;
      transition: padding 0.2s ease, background-color 0.2s ease;
    }
    .audio-card--expanded {
      padding-bottom: 32px !important;
      background-color: rgba(31, 41, 55, 0.85);
    }
    .audio-card button[data-role="play-button"] {
      flex-shrink: 0;
    }
    .audio-card__header {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 0.75rem;
    }
    .audio-card__title {
      margin: 0;
    }
    .audio-card__controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      justify-content: flex-end;
    }
    .audio-card__controls button {
      flex-shrink: 0;
      transition: transform 0.15s ease, background-color 0.15s ease;
    }
    .audio-card__controls [data-role="play-button"] {
      height: 3.25rem;
      width: 3.25rem;
    }
    .audio-card__controls [data-role="rewind-button"],
    .audio-card__controls [data-role="forward-button"] {
      display: none;
      height: 3rem;
      width: 3rem;
    }
    .audio-card--controls-visible .audio-card__header {
      grid-template-columns: 1fr;
    }
    .audio-card--controls-visible .audio-card__controls {
      justify-content: center;
      gap: 1.5rem;
      width: 100%;
      margin-top: 0.75rem;
    }
    .audio-card--controls-visible .audio-card__controls [data-role="play-button"] {
      height: 3.75rem;
      width: 3.75rem;
    }
    .audio-card--controls-visible .audio-card__controls [data-role="rewind-button"],
    .audio-card--controls-visible .audio-card__controls [data-role="forward-button"] {
      display: flex;
    }
    .audio-card .waveform {
      position: relative;
      width: 100%;
      height: 120px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(148, 163, 184, 0.12) 0%, rgba(30, 41, 59, 0.45) 100%);
      overflow: hidden;
      opacity: 0;
      max-height: 0;
      margin-top: 0;
      transition: max-height 0.25s ease, opacity 0.25s ease, margin-top 0.25s ease;
    }
    .audio-card .waveform::after {
      content: '';
      position: absolute;
      top: 10px;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 3px;
      border-radius: 9999px;
      background: rgba(255, 255, 255, 0.9);
      box-shadow: 0 0 12px rgba(255, 255, 255, 0.65);
      pointer-events: none;
      z-index: 3;
    }
    .audio-card .waveform-viewport {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
      border-radius: inherit;
      mask-image: linear-gradient(90deg, transparent 0%, rgba(0, 0, 0, 0.8) 15%, rgba(0, 0, 0, 0.95) 50%, rgba(0, 0, 0, 0.8) 85%, transparent 100%);
      -webkit-mask-image: linear-gradient(90deg, transparent 0%, rgba(0, 0, 0, 0.8) 15%, rgba(0, 0, 0, 0.95) 50%, rgba(0, 0, 0, 0.8) 85%, transparent 100%);
    }
    .audio-card .waveform-content {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 50%;
      width: 400%;
      min-width: 400%;
      display: flex;
      align-items: flex-end;
      gap: 3px;
      padding: 14px 80px;
      background: radial-gradient(circle at top, rgba(148, 163, 184, 0.32) 0%, rgba(15, 23, 42, 0.65) 55%, rgba(15, 23, 42, 0.9) 100%);
      opacity: 0.9;
      will-change: transform;
      transform: translateX(0px);
      transition: transform 0.12s linear;
      pointer-events: none;
    }
    .audio-card .waveform-bar {
      flex: 0 0 4px;
      min-width: 4px;
      border-radius: 4px 4px 0 0;
      background: linear-gradient(180deg, rgba(94, 234, 212, 0.85) 0%, rgba(94, 234, 212, 0.45) 60%, rgba(30, 64, 175, 0.35) 100%);
      opacity: 0.95;
      box-shadow: 0 6px 14px -10px rgba(94, 234, 212, 0.8);
    }
    .audio-card--expanded .waveform {
      opacity: 1;
      max-height: 120px;
      margin-top: 20px;
    }
    /* Recorder */
    .recorder-section {
      margin-top: 2.5rem;
      border-radius: 0.75rem;
      background: rgba(31, 41, 55, 0.85);
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .recorder-section__label span {
      display: block;
      margin-bottom: 0.35rem;
      font-size: 0.9rem;
      color: rgba(226, 232, 240, 0.8);
    }
    .recorder-section__input {
      width: 100%;
      border-radius: 0.5rem;
      border: 1px solid rgba(148, 163, 184, 0.2);
      background: rgba(15, 23, 42, 0.85);
      padding: 0.75rem 1rem;
      color: #f8fafc;
      outline: none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .recorder-section__input:focus {
      border-color: rgba(79, 70, 229, 0.65);
      box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.2);
    }
    .recorder-section__controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }
    .recorder-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 9999px;
      padding: 0.75rem 1.5rem;
      font-weight: 600;
      background: rgba(55, 65, 81, 0.9);
      color: #f8fafc;
      transition: transform 0.15s ease, background-color 0.2s ease, opacity 0.2s ease;
    }
    .recorder-button[hidden] {
      display: none !important;
    }
    .recorder-button--round {
      width: 4rem;
      height: 4rem;
      padding: 0;
      border-radius: 50%;
      font-size: 0.85rem;
      line-height: 1.1;
      text-align: center;
      word-break: break-word;
      flex-direction: column;
      justify-content: center;
      gap: 0.15rem;
    }
    .recorder-button__subtext {
      font-size: 0.6rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      line-height: 1;
    }
    .recorder-button:not(:disabled):hover {
      transform: translateY(-1px);
      background: rgba(71, 85, 105, 0.95);
    }
    .recorder-button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    .recorder-button--primary {
      background: var(--primary-color);
    }
    .recorder-button--primary:not(:disabled):hover {
      background: #0f6ad1;
    }
    .recorder-button--accent {
      background: rgba(16, 185, 129, 0.85);
    }
    .recorder-button--accent:not(:disabled):hover {
      background: rgba(5, 150, 105, 0.85);
    }
    .recorder-button--destructive {
      background: rgba(239, 68, 68, 0.8);
    }
    .recorder-button--destructive:not(:disabled):hover {
      background: rgba(220, 38, 38, 0.85);
    }
    .recorder-section__status {
      font-size: 0.95rem;
      color: rgba(226, 232, 240, 0.78);
    }
    .recorder-section__status[data-tone="warning"] {
      color: #facc15;
    }
    .recorder-section__status[data-tone="error"] {
      color: #f87171;
    }
    .recorder-section__status[data-tone="success"] {
      color: #4ade80;
    }
    .recorder-section__status[data-tone="info"] {
      color: #60a5fa;
    }
    .recorder-section__preview {
      width: 100%;
      display: none;
    }
    .recorder-section__preview.recorder-section__preview--visible {
      display: block;
    }
  </style>
  </head>
<body class="bg-gray-900">
<div class="relative flex h-auto min-h-screen w-full flex-col bg-gray-900 justify-between group/design-root" style='font-family: Inter, "Noto Sans", sans-serif;'>
<div>
<header class="sticky top-0 z-10 bg-gray-900/80 backdrop-blur-sm" style="height: 60px;">
<div class="flex items-center p-4">
<a href="songs.html" id="back-to-songs" class="text-white">
<span class="material-symbols-outlined text-3xl">
                        arrow_back_ios_new
                    </span>
</a>
<h1 class="flex-1 text-center text-xl font-bold text-white pr-8">Pistas de práctica</h1>
</div>
</header>
<main class="p-4">
<h2 class="text-3xl font-bold text-white mb-6">Pistas de Práctica</h2>
<div class="mb-4" data-song-status-container hidden>
  <button type="button" class="song-status-button" data-song-status-button disabled>Not started</button>
</div>
<div class="space-y-4">
</div>
<section class="recorder-section" data-recorder-section>
  <h3 class="text-xl font-semibold text-white">Record New Audio</h3>
  <label class="recorder-section__label">

    <input type="text" class="recorder-section__input" placeholder="Enter a title please" data-recorder-field="title"/>
  </label>
  <div class="recorder-section__status" data-recorder-status data-tone="neutral">Press "Record" to start and add a title when you are ready.</div>
  <div class="recorder-section__controls">
    <button type="button" class="recorder-button recorder-button--primary recorder-button--round" data-recorder-action="toggle">Record</button>
    <button type="button" class="recorder-button recorder-button--accent" data-recorder-action="upload" data-recorder-visibility="hasRecording" hidden disabled>Upload recording</button>
    <button type="button" class="recorder-button recorder-button--destructive" data-recorder-action="discard" data-recorder-visibility="hasRecording" hidden disabled>Discard</button>
  </div>
  <audio class="recorder-section__preview" data-recorder-preview controls preload="metadata"></audio>
</section>
</main>
</div>
</div>

<button id="upload-audio-fab" class="fixed bottom-6 right-6 flex h-14 w-14 items-center justify-center rounded-full bg-red-500 text-white shadow-lg" style="z-index:25;">
  <span class="material-symbols-outlined text-3xl">add</span>
</button>
<input id="audio-file-input" type="file" accept="audio/*" class="hidden" />

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="config.js"></script>
<script>
const supabase = window.supabase.createClient(window.SUPABASE_URL, window.SUPABASE_ANON_KEY);
const urlParams = new URLSearchParams(window.location.search);
const userId = urlParams.get('id');
const title = urlParams.get('title');
const songIdParam = urlParams.get('songId');
const normalizedUserId = coerceNumericId(userId);

const STATUS_CYCLE = ['Not started', 'Practicing', 'Completed'];
const DEFAULT_STATUS = STATUS_CYCLE[0];
const songStatusUi = {
  container: document.querySelector('[data-song-status-container]'),
  button: document.querySelector('[data-song-status-button]')
};
let currentSongStatus = DEFAULT_STATUS;
let songStatusFetchToken = 0;
let songStatusClickBound = false;

const AUDIO_BUCKET = 'audios';
const playbackCache = new Map();
let currentAudioInstance = null;
let currentAudioButton = null;
let currentSongIdResolved = null;
let audiosChannel = null;
let audiosRefreshTimeout = null;
let currentExpandedCard = null;
let currentAudioCacheEntry = null;
let audiosSongColumn = 'relational_song_id';
const AUDIO_SONG_COLUMN_CANDIDATES = ['relational_song_id', 'song_id', 'cancion_id'];

let mediaRecorder = null;
let recorderStream = null;
let recordedChunks = [];
let recordingBlob = null;
let recordingObjectUrl = null;
let recorderMimeType = 'audio/webm';
let isUploadingRecording = false;
let recorderElements = null;

const WAVEFORM_VIEW_WINDOW_SECONDS = 4;
const WAVEFORM_HALF_WINDOW_SECONDS = WAVEFORM_VIEW_WINDOW_SECONDS / 2;
const WAVEFORM_BAR_WIDTH = 4;
const WAVEFORM_BAR_GAP = 3;
const WAVEFORM_BAR_STEP = WAVEFORM_BAR_WIDTH + WAVEFORM_BAR_GAP;
const WAVEFORM_MIN_BAR_COUNT = 160;
const WAVEFORM_MAX_BAR_COUNT = 1024;
const WAVEFORM_SAMPLES_PER_SECOND = 32;
const SEEK_OFFSET_SECONDS = 3;
const RECORDER_MIME_TYPES = [
  'audio/mpeg',
  'audio/mp3',
  'audio/webm;codecs=opus',
  'audio/webm',
  'audio/ogg;codecs=opus',
  'audio/mp4;codecs=mp4a.40.2'
];
const RECORDING_COUNTDOWN_SECONDS = 3;

let waveformAudioContext = null;

function getWaveformAudioContext() {
  if (waveformAudioContext) return waveformAudioContext;
  const ContextCtor = window.AudioContext || window.webkitAudioContext;
  if (!ContextCtor) {
    console.warn('AudioContext no está disponible en este navegador; no se podrá renderizar la forma de onda real.');
    return null;
  }
  try {
    waveformAudioContext = new ContextCtor();
  } catch (err) {
    console.warn('No se pudo crear un AudioContext para la forma de onda:', err);
    waveformAudioContext = null;
  }
  return waveformAudioContext;
}

function stopWaveformAnimation(cacheEntry) {
  if (!cacheEntry) return;
  if (cacheEntry.waveformAnimationId) {
    cancelAnimationFrame(cacheEntry.waveformAnimationId);
    cacheEntry.waveformAnimationId = null;
  }
}

function startWaveformAnimation(cacheEntry) {
  if (!cacheEntry || cacheEntry.waveformAnimationId) return;
  const step = () => {
    if (!cacheEntry.player || cacheEntry.player.paused) {
      cacheEntry.waveformAnimationId = null;
      return;
    }
    applyWaveformPosition(cacheEntry.waveform, cacheEntry.player.currentTime, cacheEntry.player.duration);
    cacheEntry.waveformAnimationId = requestAnimationFrame(step);
  };
  cacheEntry.waveformAnimationId = requestAnimationFrame(step);
}

function ensureWaveformBarElements(state, count) {
  if (!state || !state.contentEl) return [];
  const sanitizedCount = Math.max(0, Math.min(count || 0, WAVEFORM_MAX_BAR_COUNT));
  let bars = Array.from(state.contentEl.children);

  if (bars.length > sanitizedCount) {
    for (let index = bars.length - 1; index >= sanitizedCount; index -= 1) {
      state.contentEl.removeChild(bars[index]);
    }
    bars = Array.from(state.contentEl.children);
  } else if (bars.length < sanitizedCount) {
    const fragment = document.createDocumentFragment();
    for (let index = bars.length; index < sanitizedCount; index += 1) {
      const bar = document.createElement('div');
      bar.className = 'waveform-bar';
      fragment.appendChild(bar);
    }
    state.contentEl.appendChild(fragment);
    bars = Array.from(state.contentEl.children);
  }

  state.barElements = bars;
  state.barCount = bars.length;
  state.minContentWidth = Math.max(state.minContentWidth || 0, bars.length * WAVEFORM_BAR_STEP + 160);
  return bars;
}

function placeholderWaveformValue(index, total) {
  if (!Number.isFinite(total) || total <= 0) return 0.3;
  const t = index / total;
  const base = 0.35 + 0.25 * Math.sin(t * Math.PI * 4);
  const envelope = 0.2 + 0.8 * Math.sin(Math.PI * Math.min(t, 1 - t));
  return Math.max(0.1, Math.min(1, base + envelope * 0.3));
}

function applyWaveformValues(state, values, options = {}) {
  if (!state || !state.contentEl) return;
  const sanitized = Array.isArray(values) && values.length
    ? values.map((v) => Math.max(0, Math.min(1, Number(v) || 0)))
    : null;
  const targetCount = sanitized ? sanitized.length : Math.max(WAVEFORM_MIN_BAR_COUNT, options.placeholderCount || 0);
  const bars = ensureWaveformBarElements(state, targetCount);

  const totalBars = bars.length || 1;
  for (let index = 0; index < bars.length; index += 1) {
    const amplitude = sanitized ? sanitized[index] : placeholderWaveformValue(index, totalBars);
    const height = 24 + amplitude * 92;
    bars[index].style.height = `${Math.max(12, Math.min(120, height))}px`;
    bars[index].style.opacity = `${0.4 + amplitude * 0.5}`;
  }

  state.waveformValues = sanitized;
  state.barCount = bars.length;
  state.minContentWidth = Math.max(state.minContentWidth || 0, bars.length * WAVEFORM_BAR_STEP + 160);
}

async function populateWaveformFromSource(cacheEntry, explicitUrl, explicitBlob) {
  if (!cacheEntry) return null;
  if (cacheEntry.waveformData?.values?.length) {
    if (cacheEntry.waveform) {
      applyWaveformValues(cacheEntry.waveform, cacheEntry.waveformData.values);
    }
    return cacheEntry.waveformData;
  }
  if (cacheEntry.waveformDataPromise) {
    try {
      const existing = await cacheEntry.waveformDataPromise;
      if (cacheEntry.waveform && existing?.values) {
        applyWaveformValues(cacheEntry.waveform, existing.values);
      }
      return existing;
    } catch (err) {
      return null;
    }
  }

  const sourceBlob = explicitBlob || cacheEntry.sourceBlob || null;
  const sourceUrl = explicitUrl || cacheEntry.sourceUrl || null;
  if (!sourceBlob && !sourceUrl) return null;

  const generationPromise = (async () => {
    try {
      let arrayBuffer = null;
      if (sourceBlob) {
        arrayBuffer = await sourceBlob.arrayBuffer();
      } else if (sourceUrl) {
        const response = await fetch(sourceUrl, { mode: 'cors' });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        arrayBuffer = await response.arrayBuffer();
      }

      if (!arrayBuffer) return null;

      const audioContext = getWaveformAudioContext();
      if (!audioContext) return null;

      if (audioContext.state === 'suspended') {
        try {
          await audioContext.resume();
        } catch (resumeErr) {
          console.debug('No se pudo reanudar el AudioContext antes de decodificar:', resumeErr);
        }
      }

      const decodedBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));
      const channelData = decodedBuffer.getChannelData(0);
      if (!channelData || !channelData.length) return null;

      const duration = decodedBuffer.duration || cacheEntry.player?.duration || 0;
      const totalSamples = channelData.length;
      const desiredCount = Math.max(
        WAVEFORM_MIN_BAR_COUNT,
        Math.min(
          WAVEFORM_MAX_BAR_COUNT,
          Math.round((duration || totalSamples / decodedBuffer.sampleRate) * WAVEFORM_SAMPLES_PER_SECOND)
        )
      );
      const blockSize = Math.max(1, Math.floor(totalSamples / desiredCount));
      const amplitudes = [];

      for (let i = 0; i < desiredCount; i += 1) {
        const start = i * blockSize;
        let sum = 0;
        for (let j = 0; j < blockSize && (start + j) < totalSamples; j += 1) {
          sum += Math.abs(channelData[start + j]);
        }
        const avg = sum / blockSize;
        amplitudes.push(Math.min(1, Math.max(0, avg * 2.8)));
      }

      return { values: amplitudes, duration };
    } catch (err) {
      console.error('No se pudo generar la forma de onda real:', err);
      return null;
    }
  })();

  cacheEntry.waveformDataPromise = generationPromise;

  try {
    const result = await generationPromise;
    cacheEntry.waveformDataPromise = null;
    if (result?.values?.length) {
      cacheEntry.waveformData = result;
      if (cacheEntry.waveform) {
        applyWaveformValues(cacheEntry.waveform, result.values);
        if (!cacheEntry.waveform.duration && result.duration) {
          cacheEntry.waveform.duration = result.duration;
        }
      }
    }
    return result;
  } catch (err) {
    cacheEntry.waveformDataPromise = null;
    console.error('Error inesperado generando la forma de onda:', err);
    return null;
  }
}

let recorderCountdownTimer = null;
let recorderCountdownRemaining = 0;
let isRecorderCountdownActive = false;

const backLink = document.getElementById('back-to-songs');
if (backLink) {
  backLink.href = userId ? `songs.html?id=${encodeURIComponent(userId)}` : 'songs.html';
}

// Helper: probe candidate tables for a song record by id and update page titles
async function fetchAndApplySongTitle(songId) {
  if (!songId) return null;
  const idVal = Number.isFinite(Number(songId)) ? Number(songId) : songId;

  const candidates = [
    { table: 'songs', select: 'id, title, artists ( name )', getTitle: (d) => d.title },
    { table: 'canciones', select: 'id, nombres_canciones ( titulo ), artistas ( nombre )', getTitle: (d) => d.nombres_canciones?.titulo }
  ];

  for (const c of candidates) {
    try {
      const { data, error } = await supabase
        .from(c.table)
        .select(c.select)
        .eq('id', idVal)
        .limit(1)
        .single();

      if (!error && data) {
        const songTitle = c.getTitle(data) || urlParams.get('title') || 'Pistas de práctica';
        const headerH1 = document.querySelector('header h1');
        const mainH2 = document.querySelector('main h2');
        if (headerH1) headerH1.textContent = songTitle;
        if (mainH2) mainH2.textContent = songTitle;
        try { document.title = songTitle + ' — Stitch Design'; } catch (e) {}
        currentSongIdResolved = data?.id || null;
        // Return a normalized record with a consistent title field
        return { id: data.id, title: songTitle, raw: data };
      }
    } catch (err) {
      // If the table doesn't exist, PostgREST responds with code PGRST205.
      // Log and continue to next candidate without failing the whole flow.
      console.debug(`probe ${c.table} failed:`, err?.message || err, err?.code || null);
      continue;
    }
  }

  // Fallback to URL title param
  const fallback = urlParams.get('title') || 'Pistas de práctica';
  const headerH1 = document.querySelector('header h1');
  const mainH2 = document.querySelector('main h2');
  if (headerH1) headerH1.textContent = fallback;
  if (mainH2) mainH2.textContent = fallback;
  try { document.title = fallback + ' — Stitch Design'; } catch (e) {}
  return null;
}

// Helper: try to find a song by title (used when only a title param is available)
async function probeSongByTitle(titleStr) {
  if (!titleStr) return null;
  try {
    // Prefer the canonical 'songs' table
    const { data, error } = await supabase
      .from('songs')
      .select('id, title, artists ( name )')
      .ilike('title', titleStr)
      .limit(1)
      .single();
    if (!error && data) {
      return { id: data.id, title: data.title, raw: data };
    }
  } catch (err) {
    console.debug('probeSongByTitle: songs table lookup failed:', err?.message || err);
  }
  return null;
}

// Apply title on load
if (songIdParam) {
  fetchAndApplySongTitle(songIdParam);
} else if (title) {
  const headerH1 = document.querySelector('header h1');
  const mainH2 = document.querySelector('main h2');
  if (headerH1) headerH1.textContent = title;
  if (mainH2) mainH2.textContent = title;
}

function coerceNumericId(value) {
  if (value === null || value === undefined) return value;
  if (typeof value === 'number') {
    return Number.isFinite(value) ? value : value;
  }
  if (typeof value === 'string' && /^\d+$/.test(value)) {
    const asNumber = Number(value);
    return Number.isSafeInteger(asNumber) ? asNumber : value;
  }
  return value;
}

function normalizeStatusTag(value) {
  return (value || '').toLowerCase().replace(/\s+/g, '-');
}

function getNextStatusTag(currentStatus) {
  const index = STATUS_CYCLE.indexOf(currentStatus);
  if (index === -1 || index === STATUS_CYCLE.length - 1) {
    return STATUS_CYCLE[0];
  }
  return STATUS_CYCLE[index + 1];
}

function applyStatusStyles(button, statusTag) {
  if (!button) return;
  const resolvedStatus = STATUS_CYCLE.includes(statusTag) ? statusTag : DEFAULT_STATUS;
  const normalized = normalizeStatusTag(resolvedStatus);
  button.textContent = resolvedStatus;
  button.dataset.status = resolvedStatus;
  STATUS_CYCLE.forEach(state => {
    button.classList.remove(`song-status-button--${normalizeStatusTag(state)}`);
  });
  button.classList.add(`song-status-button--${normalized}`);
}

function setSongStatusLoading(isLoading) {
  if (!songStatusUi.button) return;
  if (isLoading) {
    songStatusUi.button.disabled = true;
    songStatusUi.button.dataset.loading = 'true';
  } else {
    delete songStatusUi.button.dataset.loading;
    songStatusUi.button.disabled = songStatusUi.container ? songStatusUi.container.hidden : true;
  }
}

async function fetchUserSongStatusTag(songId) {
  if (!normalizedUserId || songId === null || songId === undefined) {
    return null;
  }
  const normalizedSongId = coerceNumericId(songId);
  const { data, error } = await supabase
    .from('user_songs')
    .select('status_tag')
    .eq('user_id', normalizedUserId)
    .eq('song_id', normalizedSongId)
    .maybeSingle();

  if (error) {
    throw error;
  }

  if (!data) {
    return null;
  }

  return data.status_tag || DEFAULT_STATUS;
}

async function persistUserSongStatus(songId, nextStatus) {
  if (!normalizedUserId) {
    throw new Error('No user selected.');
  }
  const normalizedSongId = coerceNumericId(songId);
  const { data, error } = await supabase
    .from('user_songs')
    .update({ status_tag: nextStatus })
    .eq('user_id', normalizedUserId)
    .eq('song_id', normalizedSongId)
    .select('status_tag')
    .maybeSingle();

  if (error) {
    throw error;
  }

  if (!data) {
    throw new Error('No matching user_songs row was updated.');
  }

  return data.status_tag || nextStatus;
}

async function refreshSongStatusUi(songId) {
  if (!songStatusUi.button) {
    return;
  }
  if (!normalizedUserId || songId === null || songId === undefined) {
    if (songStatusUi.container) {
      songStatusUi.container.hidden = true;
    }
    currentSongStatus = DEFAULT_STATUS;
    applyStatusStyles(songStatusUi.button, currentSongStatus);
    setSongStatusLoading(false);
    return;
  }

  const fetchToken = ++songStatusFetchToken;
  setSongStatusLoading(true);

  try {
    const statusTag = await fetchUserSongStatusTag(songId);
    if (songStatusFetchToken !== fetchToken) {
      return;
    }

    if (!statusTag) {
      currentSongStatus = DEFAULT_STATUS;
      applyStatusStyles(songStatusUi.button, currentSongStatus);
      if (songStatusUi.container) {
        songStatusUi.container.hidden = true;
      }
      return;
    }

    currentSongStatus = STATUS_CYCLE.includes(statusTag) ? statusTag : DEFAULT_STATUS;
    applyStatusStyles(songStatusUi.button, currentSongStatus);
    if (songStatusUi.container) {
      songStatusUi.container.hidden = false;
    }
  } catch (err) {
    if (songStatusFetchToken !== fetchToken) {
      return;
    }
    console.error('Error fetching status_tag:', err);
    currentSongStatus = DEFAULT_STATUS;
    applyStatusStyles(songStatusUi.button, currentSongStatus);
    if (songStatusUi.container) {
      songStatusUi.container.hidden = true;
    }
  } finally {
    if (songStatusFetchToken === fetchToken) {
      setSongStatusLoading(false);
    }
  }
}

function initSongStatusControls() {
  if (!songStatusUi.button) {
    return;
  }

  applyStatusStyles(songStatusUi.button, currentSongStatus);
  songStatusUi.button.disabled = true;

  if (!normalizedUserId) {
    if (songStatusUi.container) {
      songStatusUi.container.hidden = true;
    }
    return;
  }

  if (songStatusClickBound) {
    return;
  }
  songStatusClickBound = true;

  songStatusUi.button.addEventListener('click', async (event) => {
    event.preventDefault();
    if (!normalizedUserId || currentSongIdResolved === null || currentSongIdResolved === undefined) {
      return;
    }

    const currentStatus = songStatusUi.button.dataset.status || currentSongStatus || DEFAULT_STATUS;
    const nextStatus = getNextStatusTag(currentStatus);

    applyStatusStyles(songStatusUi.button, nextStatus);
    setSongStatusLoading(true);

    try {
      const persisted = await persistUserSongStatus(currentSongIdResolved, nextStatus);
      currentSongStatus = STATUS_CYCLE.includes(persisted) ? persisted : DEFAULT_STATUS;
      applyStatusStyles(songStatusUi.button, currentSongStatus);
      if (songStatusUi.container) {
        songStatusUi.container.hidden = false;
      }
    } catch (err) {
      console.error('Error updating status_tag:', err);
      currentSongStatus = STATUS_CYCLE.includes(currentStatus) ? currentStatus : DEFAULT_STATUS;
      applyStatusStyles(songStatusUi.button, currentSongStatus);
    } finally {
      setSongStatusLoading(false);
    }
  });
}

function setCardControlsVisibility(card, visible) {
  if (!card) return;
  card.classList.toggle('audio-card--controls-visible', !!visible);
}

function setButtonPlaying(button, isPlaying) {
  if (!button) return;
  const icon = button.querySelector('.material-symbols-outlined');
  if (icon) {
    icon.textContent = isPlaying ? 'pause' : 'play_arrow';
  }
  button.dataset.playing = isPlaying ? 'true' : 'false';
}

function stopCurrentAudio() {
  if (currentAudioInstance) {
    currentAudioInstance.pause();
    currentAudioInstance.currentTime = 0;
  }
  if (currentAudioButton) {
    setButtonPlaying(currentAudioButton, false);
    const audioCard = currentAudioButton.closest('.audio-card');
    const audioId = audioCard?.dataset?.audioId ? Number(audioCard.dataset.audioId) : null;
    if (audioCard) {
      setCardControlsVisibility(audioCard, false);
    }
    if (audioId && playbackCache.has(audioId)) {
      const cached = playbackCache.get(audioId);
  } else if (currentAudioCacheEntry) {
    stopWaveformAnimation(currentAudioCacheEntry);
    if (currentAudioCacheEntry.waveform) {
      resetWaveformState(currentAudioCacheEntry.waveform);
    }
      if (cached?.waveform) {
      if (cached) {
        stopWaveformAnimation(cached);
      }
      }
    }
  }
  currentAudioInstance = null;
  currentAudioButton = null;
}

  currentAudioCacheEntry = null;
function computeWaveformMetrics(viewportEl) {
  if (!viewportEl) return null;
  const width = viewportEl.getBoundingClientRect().width || viewportEl.offsetWidth || 0;
  if (!width) return null;
  return {
    viewportWidth: width,
    initialOffset: width / 2,
    pixelsPerSecond: width / WAVEFORM_VIEW_WINDOW_SECONDS
  };
}

function refreshWaveformMetrics(state) {
  if (!state) return null;
  const metrics = computeWaveformMetrics(state.viewportEl);
  if (!metrics) return null;
  state.metrics = metrics;
  return metrics;
}

function updateWaveformDimensions(state, duration) {
  if (!state || !state.contentEl) return;
  const metrics = state.metrics || refreshWaveformMetrics(state);
  if (!metrics) {
    requestAnimationFrame(() => updateWaveformDimensions(state, duration));
    return;
  }
  const effectiveDuration = Number.isFinite(duration) && duration > 0 ? duration : 0;
  const totalWidth = metrics.initialOffset + (effectiveDuration + WAVEFORM_HALF_WINDOW_SECONDS) * metrics.pixelsPerSecond;
  const minWidth = Math.max(state.minContentWidth || 0, metrics.viewportWidth * 1.5);
  state.contentEl.style.width = `${Math.max(totalWidth, minWidth)}px`;
}

function applyWaveformPosition(state, currentTime, duration) {
  if (!state || !state.contentEl) return;
  const metrics = state.metrics || refreshWaveformMetrics(state);
  if (!metrics) {
    requestAnimationFrame(() => applyWaveformPosition(state, currentTime, duration));
    return;
  }
  const effectiveTime = Math.max(0, Number(currentTime) || 0);
  const effectiveDuration = Number.isFinite(duration) && duration > 0 ? duration : 0;
  state.duration = effectiveDuration;
  state.lastCurrentTime = effectiveTime;
  updateWaveformDimensions(state, effectiveDuration);
  const contentWidth = state.contentEl.offsetWidth || 0;
  const minOffset = metrics.viewportWidth - contentWidth;
  const offset = Math.max(minOffset, metrics.initialOffset - (effectiveTime * metrics.pixelsPerSecond));
  state.contentEl.style.transform = `translateX(${offset}px)`;
}

function resetWaveformState(state) {
  if (!state || !state.contentEl) return;
  const metrics = refreshWaveformMetrics(state);
  if (!metrics) {
    requestAnimationFrame(() => resetWaveformState(state));
    return;
  }
  state.lastCurrentTime = 0;
  updateWaveformDimensions(state, state.duration || 0);
  state.contentEl.style.transform = `translateX(${metrics.initialOffset}px)`;
}

function buildWaveformState(waveformElements, seed) {
  if (!waveformElements) return null;
  const { viewportEl, contentEl } = waveformElements;
  if (!viewportEl || !contentEl) return null;
  const state = {
    viewportEl,
    contentEl,
    metrics: computeWaveformMetrics(viewportEl),
    duration: 0,
    lastCurrentTime: 0,
    barCount: 0,
    minContentWidth: 0,
    waveformValues: null
  };
  applyWaveformValues(state, null, { placeholderCount: WAVEFORM_MIN_BAR_COUNT });
  if (state.metrics) {
    state.contentEl.style.transform = `translateX(${state.metrics.initialOffset}px)`;
  } else {
    requestAnimationFrame(() => {
      const metrics = refreshWaveformMetrics(state);
      if (metrics) {
        state.contentEl.style.transform = `translateX(${metrics.initialOffset}px)`;
      }
    });
  }
  return state;
}

function collapseCurrentCard() {
  if (!currentExpandedCard) return;
  const card = currentExpandedCard;
  if (currentAudioButton && currentAudioButton.closest('.audio-card') === card) {
    stopCurrentAudio();
  }
  const audioId = card.dataset?.audioId ? Number(card.dataset.audioId) : null;
  if (audioId && playbackCache.has(audioId)) {
    const cached = playbackCache.get(audioId);
    if (cached?.waveform) {
      resetWaveformState(cached.waveform);
    }
  }
  card.classList.remove('audio-card--expanded');
  setCardControlsVisibility(card, false);
  currentExpandedCard = null;
}

function expandCard(card) {
  if (!card) return;
  if (currentExpandedCard === card) return;
  collapseCurrentCard();
  card.classList.add('audio-card--expanded');
  setCardControlsVisibility(card, true);
  const audioId = card.dataset?.audioId ? Number(card.dataset.audioId) : null;
  if (audioId && playbackCache.has(audioId)) {
    const cached = playbackCache.get(audioId);
    if (cached?.waveform) {
      refreshWaveformMetrics(cached.waveform);
      resetWaveformState(cached.waveform);
      if (!cached.waveformData?.values?.length) {
        populateWaveformFromSource(cached).catch((err) => {
          console.debug('No se pudo generar la forma de onda al expandir la tarjeta', audioId, err?.message || err);
        });
      }
    }
  }
  currentExpandedCard = card;
}

function clearPlaybackCache() {
  stopCurrentAudio();
  playbackCache.forEach((entry) => {
    const { player, revoke, waveform, cleanup } = entry;
    stopWaveformAnimation(entry);
    try {
      if (player) {
        player.pause();
        player.currentTime = 0;
      }
    } catch (err) {
      console.warn('No se pudo detener un reproductor en caché:', err);
    }
    if (waveform) {
      resetWaveformState(waveform);
    }
    if (typeof cleanup === 'function') {
      try {
        cleanup();
      } catch (cleanupErr) {
        console.warn('No se pudo limpiar eventos del reproductor:', cleanupErr);
      }
    }
    if (typeof revoke === 'function') {
      try {
        revoke();
      } catch (revErr) {
        console.warn('No se pudo liberar la URL en caché:', revErr);
      }
    }
  });
  playbackCache.clear();
  collapseCurrentCard();
  currentAudioCacheEntry = null;
}

function isHttpUrl(path) {
  return typeof path === 'string' && /^https?:\/\//i.test(path);
}

// Normalize Supabase object keys so we hit the real file regardless of how the path was stored.
function normalizeAudioStoragePath(rawPath) {
  if (!rawPath || typeof rawPath !== 'string') return null;
  let path = rawPath.trim();
  if (!path) return null;
  path = path.replace(/^https?:\/\/[^/]+\/storage\/v1\/object\/[^/]+\/[^/]+\//i, '');
  path = path.replace(/^\/+/, '');
  if (!path) return null;
  if (path.startsWith(`${AUDIO_BUCKET}/`)) {
    return path;
  }
  if (path.includes('/')) {
    return path;
  }
  return `${AUDIO_BUCKET}/${path}`;
}

async function prepareAudioPlayer(audio, button, waveformElements) {
  if (!audio) return null;

  let cached = playbackCache.get(audio.id);

  if (!cached) {
    const storagePath = audio.url || null;
    if (!storagePath) {
      console.warn('El audio no tiene ruta de almacenamiento definida:', audio.id);
      return null;
    }

    let sourceUrl = null;
    let revoke = null;
    let downloadBlob = null;

    if (isHttpUrl(storagePath)) {
      sourceUrl = storagePath;
    } else {
      const downloadBucket = AUDIO_BUCKET;
      const normalizedPath = normalizeAudioStoragePath(storagePath);
      const rawCandidate = typeof storagePath === 'string' ? storagePath.trim().replace(/^\/+/, '') : null;
      const candidatePaths = [];

      if (normalizedPath) candidatePaths.push(normalizedPath);
      if (rawCandidate && !candidatePaths.includes(rawCandidate)) candidatePaths.push(rawCandidate);

      if (!candidatePaths.length) {
        console.warn('No se pudo normalizar la ruta de almacenamiento para el audio:', audio.id);
        return null;
      }

      let lastError = null;

      for (const candidate of candidatePaths) {
        try {
          const { data, error } = await supabase
            .storage
            .from(downloadBucket)
            .download(candidate);

          if (error) {
            lastError = error;
            continue;
          }

          downloadBlob = data;
          console.debug('Audio descargado', { audioId: audio.id, bucket: downloadBucket, path: candidate });
          break;
        } catch (err) {
          lastError = err;
        }
      }

      if (!downloadBlob) {
        console.error(`No se pudo descargar el audio ${storagePath}:`, lastError || {});
        return null;
      }

      sourceUrl = URL.createObjectURL(downloadBlob);
      revoke = () => URL.revokeObjectURL(sourceUrl);
    }

    const audioElement = new Audio(sourceUrl);
    const cacheEntry = {
      player: audioElement,
      revoke,
      playButtonRef: button || null,
      waveform: waveformElements ? buildWaveformState(waveformElements, audio.id) : null,
      waveformData: null,
      waveformDataPromise: null,
      sourceUrl,
      sourceBlob: downloadBlob || null,
      storagePath,
      waveformAnimationId: null,
      cleanup: null
    };

    const handleEnded = () => {
      if (currentAudioInstance === audioElement) {
        stopCurrentAudio();
      } else if (cacheEntry.playButtonRef && cacheEntry.playButtonRef.dataset.playing === 'true') {
        setButtonPlaying(cacheEntry.playButtonRef, false);
        const card = cacheEntry.playButtonRef.closest('.audio-card');
        setCardControlsVisibility(card, false);
      }
      stopWaveformAnimation(cacheEntry);
      if (cacheEntry.waveform) {
        resetWaveformState(cacheEntry.waveform);
      }
    };

    const handleProgress = () => applyWaveformPosition(cacheEntry.waveform, audioElement.currentTime, audioElement.duration);
    const handleLoadedMetadata = () => applyWaveformPosition(cacheEntry.waveform, audioElement.currentTime, audioElement.duration);

    audioElement.addEventListener('ended', handleEnded);
    audioElement.addEventListener('timeupdate', handleProgress);
    audioElement.addEventListener('loadedmetadata', handleLoadedMetadata);
    audioElement.addEventListener('seeking', handleProgress);
    audioElement.addEventListener('emptied', handleProgress);

    cacheEntry.cleanup = () => {
      stopWaveformAnimation(cacheEntry);
      audioElement.removeEventListener('ended', handleEnded);
      audioElement.removeEventListener('timeupdate', handleProgress);
      audioElement.removeEventListener('loadedmetadata', handleLoadedMetadata);
      audioElement.removeEventListener('seeking', handleProgress);
      audioElement.removeEventListener('emptied', handleProgress);
    };

    playbackCache.set(audio.id, cacheEntry);
    cached = cacheEntry;

    populateWaveformFromSource(cacheEntry, sourceUrl, downloadBlob).catch((err) => {
      console.debug('No se pudo inicializar la forma de onda para el audio', audio.id, err?.message || err);
    });
  }

  if (waveformElements) {
    const rebuiltState = buildWaveformState(waveformElements, audio.id);
    if (rebuiltState) {
      cached.waveform = rebuiltState;
      if (cached.waveformData?.values?.length) {
        applyWaveformValues(cached.waveform, cached.waveformData.values);
      } else {
        populateWaveformFromSource(cached).catch((err) => {
          console.debug('No se pudo actualizar la forma de onda para el audio', audio.id, err?.message || err);
        });
      }
      applyWaveformPosition(cached.waveform, cached.player?.currentTime || 0, cached.player?.duration || 0);
    }
  }

  if (button) {
    cached.playButtonRef = button;
  }

  if (!cached.waveformData?.values?.length) {
    populateWaveformFromSource(cached).catch((err) => {
      console.debug('No se pudo completar la forma de onda para el audio', audio.id, err?.message || err);
    });
  }

  return cached;
}

async function togglePlayback(button, audio, waveformElements) {
  if (!button || !audio) return;

  const cached = await prepareAudioPlayer(audio, button, waveformElements);
  if (!cached) {
    setButtonPlaying(button, false);
    return;
  }

  const { player } = cached;

  if (currentAudioInstance && currentAudioInstance !== player) {
    stopCurrentAudio();
  }

  if (player.paused) {
    try {
      await player.play();
      currentAudioInstance = player;
      currentAudioButton = button;
      currentAudioCacheEntry = cached;
      setButtonPlaying(button, true);
      setCardControlsVisibility(button.closest('.audio-card'), true);
      applyWaveformPosition(cached.waveform, player.currentTime, player.duration);
      startWaveformAnimation(cached);
    } catch (err) {
      console.error('No se pudo reproducir el audio:', err);
      setButtonPlaying(button, false);
      if (cached.waveform) {
        resetWaveformState(cached.waveform);
      }
      stopWaveformAnimation(cached);
    }
  } else {
    player.pause();
    setButtonPlaying(button, false);
    stopWaveformAnimation(cached);
    currentAudioCacheEntry = null;
  }
}

async function seekPlayback(audio, offsetSeconds, waveformElements) {
  if (!audio || !Number.isFinite(offsetSeconds)) return;

  const cached = await prepareAudioPlayer(audio, null, waveformElements);
  if (!cached) return;

  const { player, waveform } = cached;

  const ensureDurationReady = () => new Promise((resolve) => {
    let resolved = false;
    const markResolved = () => {
      if (resolved) return;
      resolved = true;
      clearTimeout(timeoutId);
      player.removeEventListener('loadedmetadata', markResolved);
      player.removeEventListener('durationchange', markResolved);
      resolve();
    };
    const timeoutId = setTimeout(markResolved, 1200);
    player.addEventListener('loadedmetadata', markResolved);
    player.addEventListener('durationchange', markResolved);
    if (Number.isFinite(player.duration)) {
      markResolved();
    }
  });

  if (!Number.isFinite(player.duration)) {
    try {
      await ensureDurationReady();
    } catch (err) {
      console.warn('No se pudo obtener la duración del audio antes de buscar:', err);
    }
  }

  const duration = Number.isFinite(player.duration) ? player.duration : null;
  const currentTime = Number.isFinite(player.currentTime) ? player.currentTime : 0;
  let nextTime = currentTime + offsetSeconds;

  if (duration !== null) {
    nextTime = Math.min(duration, nextTime);
  }

  nextTime = Math.max(0, nextTime);

  try {
    player.currentTime = nextTime;
  } catch (err) {
    console.warn('No se pudo ajustar el tiempo de reproducción:', err);
    return;
  }

  if (waveform) {
    applyWaveformPosition(waveform, nextTime, duration ?? player.duration);
  }
}

function attachSeekControl(button, audio, card, offsetSeconds, waveformElements) {
  if (!button) return;
  button.addEventListener('click', async (event) => {
    event.stopPropagation();
    expandCard(card);
    await seekPlayback(audio, offsetSeconds, waveformElements);
  });
}

// Recorder helpers
function ensureRecorderElements() {
  if (recorderElements) return recorderElements;
  const section = document.querySelector('[data-recorder-section]');
  if (!section) return null;
  recorderElements = {
    section,
    titleInput: section.querySelector('[data-recorder-field="title"]'),
    toggleButton: section.querySelector('[data-recorder-action="toggle"]'),
    uploadButton: section.querySelector('[data-recorder-action="upload"]'),
    discardButton: section.querySelector('[data-recorder-action="discard"]'),
    conditionalButtons: Array.from(section.querySelectorAll('[data-recorder-visibility]')),
    previewEl: section.querySelector('[data-recorder-preview]'),
    statusEl: section.querySelector('[data-recorder-status]'),
    initialized: false
  };
  return recorderElements;
}

function setRecorderStatus(message, tone = 'neutral') {
  const elements = ensureRecorderElements();
  if (!elements?.statusEl) return;
  elements.statusEl.textContent = message;
  elements.statusEl.dataset.tone = tone;
}

function setDefaultRecorderStatus() {
  if (mediaRecorder && mediaRecorder.state === 'recording') return;
  if (recordingBlob) return;
  if (!currentSongIdResolved) {
    setRecorderStatus('Select a track before recording.', 'warning');
    return;
  }
  setRecorderStatus('Press "Record" to start and add a title when you are ready.', 'neutral');
}

function cancelRecordingCountdown(options = {}) {
  const { silent = false, skipUiUpdate = false } = options;
  if (recorderCountdownTimer) {
    clearInterval(recorderCountdownTimer);
    recorderCountdownTimer = null;
  }
  const wasActive = isRecorderCountdownActive;
  recorderCountdownRemaining = 0;
  isRecorderCountdownActive = false;
  if (wasActive && !silent) {
    setDefaultRecorderStatus();
  }
  if (!skipUiUpdate) {
    updateRecorderUi();
  }
}

function beginRecordingCountdown() {
  cancelRecordingCountdown({ silent: true, skipUiUpdate: true });
  isRecorderCountdownActive = true;
  recorderCountdownRemaining = RECORDING_COUNTDOWN_SECONDS;
  setRecorderStatus(`Recording starts in ${recorderCountdownRemaining}...`, 'info');
  updateRecorderUi();

  if (recorderCountdownRemaining <= 0) {
    cancelRecordingCountdown({ silent: true, skipUiUpdate: true });
    void startRecordingCore();
    return;
  }

  recorderCountdownTimer = window.setInterval(() => {
    recorderCountdownRemaining -= 1;
    if (recorderCountdownRemaining <= 0) {
      cancelRecordingCountdown({ silent: true, skipUiUpdate: true });
      setRecorderStatus('Starting recording...', 'info');
      void startRecordingCore();
      return;
    }
    setRecorderStatus(`Recording starts in ${recorderCountdownRemaining}...`, 'info');
    updateRecorderUi();
  }, 1000);
}

function updateRecorderUi() {
  const elements = ensureRecorderElements();
  if (!elements) return;
  const isRecording = mediaRecorder && mediaRecorder.state === 'recording';
  const hasRecording = !!recordingBlob;
  const isCountingDown = isRecorderCountdownActive;

  if (elements.toggleButton) {
    const showToggle = isRecording || !hasRecording || isCountingDown;
    elements.toggleButton.hidden = !showToggle;
    if (!showToggle && document.activeElement === elements.toggleButton) {
      elements.toggleButton.blur();
    }

    if (isCountingDown) {
      elements.toggleButton.disabled = false;
      const displayNumber = recorderCountdownRemaining > 0 ? recorderCountdownRemaining : 0;
      elements.toggleButton.textContent = String(displayNumber);
      elements.toggleButton.setAttribute('aria-pressed', 'false');
      elements.toggleButton.setAttribute('aria-label', `Recording starts in ${displayNumber}`);
      elements.toggleButton.classList.add('recorder-button--primary');
      elements.toggleButton.classList.remove('recorder-button--destructive');
    } else if (isRecording) {
      elements.toggleButton.disabled = false;
      elements.toggleButton.textContent = 'Stop';
      elements.toggleButton.setAttribute('aria-pressed', 'true');
      elements.toggleButton.setAttribute('aria-label', 'Stop');
      elements.toggleButton.classList.add('recorder-button--destructive');
      elements.toggleButton.classList.remove('recorder-button--primary');
    } else {
      const canRecord = !!currentSongIdResolved && !isUploadingRecording && !hasRecording;
      elements.toggleButton.disabled = !canRecord;
      elements.toggleButton.textContent = 'Record';
      elements.toggleButton.setAttribute('aria-pressed', 'false');
      elements.toggleButton.setAttribute('aria-label', 'Start recording');
      elements.toggleButton.classList.add('recorder-button--primary');
      elements.toggleButton.classList.remove('recorder-button--destructive');
    }
  }
  if (elements.conditionalButtons?.length) {
    elements.conditionalButtons.forEach((button) => {
      const visibility = button.dataset.recorderVisibility;
      const shouldShow = visibility === 'hasRecording' ? hasRecording : true;
      button.hidden = !shouldShow;
      if (!shouldShow && document.activeElement === button) {
        button.blur();
      }
    });
  }
  elements.uploadButton.disabled = !hasRecording || isUploadingRecording;
  elements.discardButton.disabled = !hasRecording || isRecording || isUploadingRecording;
  elements.titleInput.disabled = isRecording || isUploadingRecording;

  if (elements.previewEl) {
    elements.previewEl.classList.toggle('recorder-section__preview--visible', hasRecording && !!recordingObjectUrl);
    if (!hasRecording) {
      elements.previewEl.pause();
      elements.previewEl.removeAttribute('src');
      elements.previewEl.load();
    } else if (recordingObjectUrl) {
      elements.previewEl.src = recordingObjectUrl;
    }
  }
}

function cleanupRecorderStream() {
  if (recorderStream) {
    try {
      recorderStream.getTracks().forEach((track) => track.stop());
    } catch (err) {
      console.debug('No se pudieron detener todas las pistas de la grabación:', err);
    }
  }
  recorderStream = null;
}

function resetRecordingState(options = {}) {
  const { keepInput = true, silent = false } = options;
  cancelRecordingCountdown({ silent: true, skipUiUpdate: true });
  if (recordingObjectUrl) {
    URL.revokeObjectURL(recordingObjectUrl);
    recordingObjectUrl = null;
  }
  recordingBlob = null;
  recordedChunks = [];
  const elements = ensureRecorderElements();
  if (elements) {
    if (!keepInput) {
      elements.titleInput.value = '';
    }
    if (elements.previewEl) {
      elements.previewEl.pause();
      elements.previewEl.removeAttribute('src');
      elements.previewEl.load();
      elements.previewEl.classList.remove('recorder-section__preview--visible');
    }
  }
  if (!silent) {
    setDefaultRecorderStatus();
  }
  updateRecorderUi();
}

function handleRecorderDataAvailable(event) {
  if (event?.data && event.data.size > 0) {
    recordedChunks.push(event.data);
  }
}

function handleRecorderStopped() {
  cleanupRecorderStream();
  if (mediaRecorder) {
    mediaRecorder.removeEventListener('dataavailable', handleRecorderDataAvailable);
    mediaRecorder.removeEventListener('stop', handleRecorderStopped);
  }
  mediaRecorder = null;

  if (!recordedChunks.length) {
    resetRecordingState({ keepInput: true, silent: true });
  setRecorderStatus('No audio was captured. Please try again.', 'warning');
    return;
  }

  recordingBlob = new Blob(recordedChunks, { type: recorderMimeType || 'audio/webm' });
  recordedChunks = [];
  if (recordingObjectUrl) {
    URL.revokeObjectURL(recordingObjectUrl);
  }
  recordingObjectUrl = URL.createObjectURL(recordingBlob);
  updateRecorderUi();
  setRecorderStatus('Recording ready. Add a title, then upload or discard.', 'success');
}

function determineFileExtension(mimeType) {
  if (!mimeType) return 'webm';
  if (mimeType.includes('ogg')) return 'ogg';
  if (mimeType.includes('mpeg')) return 'mp3';
  if (mimeType.includes('mp3')) return 'mp3';
  if (mimeType.includes('wav')) return 'wav';
  if (mimeType.includes('m4a') || mimeType.includes('mp4')) return 'm4a';
  return 'webm';
}

function slugifyFileName(input) {
  if (!input) return '';
  return input
    .toString()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-zA-Z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .toLowerCase();
}

async function fetchNextAudioId() {
  try {
    const { data, error } = await supabase
      .from('audios')
      .select('id')
      .order('id', { ascending: false })
      .limit(1);

    if (error) throw error;

    const lastId = data && data[0] ? Number(data[0].id) : 0;
    const nextId = Number.isFinite(lastId) && lastId > 0 ? lastId + 1 : 1;
    return nextId;
  } catch (err) {
    console.error('Unable to obtain the next audio id:', err);
    return null;
  }
}

async function startRecording() {
  const elements = ensureRecorderElements();
  if (!elements) return;

  if (isRecorderCountdownActive) {
    cancelRecordingCountdown();
    setRecorderStatus('Recording countdown canceled.', 'info');
    return;
  }

  if (!currentSongIdResolved) {
    setRecorderStatus('Select a track before recording.', 'warning');
    return;
  }

  if (recordingBlob) {
    setRecorderStatus('Upload or discard the current recording before making a new one.', 'warning');
    return;
  }

  if (!navigator.mediaDevices?.getUserMedia) {
    setRecorderStatus('This browser does not support audio recording.', 'error');
    return;
  }

  if (mediaRecorder && mediaRecorder.state === 'recording') {
    setRecorderStatus('There is already a recording in progress.', 'warning');
    return;
  }

  if (isUploadingRecording) {
    setRecorderStatus('Wait for the current upload to finish before starting a new recording.', 'warning');
    return;
  }

  resetRecordingState({ keepInput: true, silent: true });
  updateRecorderUi();
  beginRecordingCountdown();
}

async function startRecordingCore() {
  const elements = ensureRecorderElements();
  if (!elements) return;

  if (!currentSongIdResolved) {
    setRecorderStatus('Select a track before recording.', 'warning');
    updateRecorderUi();
    return;
  }

  if (!navigator.mediaDevices?.getUserMedia) {
    setRecorderStatus('This browser does not support audio recording.', 'error');
    updateRecorderUi();
    return;
  }

  try {
    setRecorderStatus('Requesting microphone access...', 'info');
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    recorderStream = stream;
    recordedChunks = [];

    let selectedMimeType = '';
    if (typeof MediaRecorder !== 'undefined' && MediaRecorder.isTypeSupported) {
      selectedMimeType = RECORDER_MIME_TYPES.find((type) => MediaRecorder.isTypeSupported(type)) || '';
    }

    mediaRecorder = selectedMimeType ? new MediaRecorder(stream, { mimeType: selectedMimeType }) : new MediaRecorder(stream);
    recorderMimeType = mediaRecorder.mimeType || selectedMimeType || 'audio/webm';

    mediaRecorder.addEventListener('dataavailable', handleRecorderDataAvailable);
    mediaRecorder.addEventListener('stop', handleRecorderStopped);

    mediaRecorder.start();
    setRecorderStatus('Recording... tap "Stop" when you are done.', 'info');
  } catch (err) {
    console.error('Unable to start recording:', err);
    cleanupRecorderStream();
    mediaRecorder = null;
    resetRecordingState({ keepInput: true, silent: true });
    setRecorderStatus('Could not access the microphone. Check your permissions.', 'error');
  }

  updateRecorderUi();
}

function stopRecording() {
  cancelRecordingCountdown({ silent: true, skipUiUpdate: true });
  if (!mediaRecorder || mediaRecorder.state !== 'recording') return;
  try {
    mediaRecorder.stop();
  setRecorderStatus('Processing the recording...', 'info');
  } catch (err) {
  console.error('Error while stopping the recording:', err);
  setRecorderStatus('The recording could not be stopped.', 'error');
  }
  updateRecorderUi();
}

function discardRecording() {
  cancelRecordingCountdown({ silent: true, skipUiUpdate: true });
  if (mediaRecorder && mediaRecorder.state === 'recording') {
  setRecorderStatus('Stop the recording before discarding it.', 'warning');
    return;
  }
  resetRecordingState({ keepInput: true, silent: true });
  setRecorderStatus('Recording discarded. You can try again.', 'info');
}

async function uploadRecording() {
  if (!recordingBlob) {
  setRecorderStatus('There is no recording to upload.', 'warning');
    return;
  }
  if (!currentSongIdResolved) {
  setRecorderStatus('Select a track before uploading the recording.', 'warning');
    return;
  }

  const elements = ensureRecorderElements();
  if (!elements) return;

  const titleValue = elements.titleInput.value.trim();
  if (!titleValue) {
    setRecorderStatus("Don't forget to enter a title.", 'warning');
    elements.titleInput.focus();
    return;
  }

  const nextAudioId = await fetchNextAudioId();
  if (!nextAudioId) {
    setRecorderStatus('Could not prepare the new audio record. Please try again later.', 'error');
    return;
  }

  const extension = determineFileExtension(recordingBlob.type || recorderMimeType);
  const safeName = slugifyFileName(titleValue).slice(0, 48) || 'recording';
  const fileName = `${safeName}.${extension}`;
  const storageName = `${nextAudioId}-${fileName}`;
  const filePath = `audios/${storageName}`;
  const uploaderId = (() => {
    if (!userId) return null;
    const numericId = Number(userId);
    return Number.isFinite(numericId) ? numericId : userId;
  })();

  isUploadingRecording = true;
  updateRecorderUi();
  setRecorderStatus('Uploading recording...', 'info');

  try {
    const { error: uploadError } = await supabase
      .storage
      .from(AUDIO_BUCKET)
      .upload(filePath, recordingBlob, {
        cacheControl: '3600',
        upsert: false,
        contentType: recordingBlob.type || recorderMimeType || 'audio/webm'
      });

    if (uploadError) {
  console.error('Error uploading the recording:', uploadError);
  setRecorderStatus('The recording could not be uploaded. Please try again.', 'error');
      return;
    }

    const insertPayload = {
      id: nextAudioId,
      instrument: titleValue,
      detail: 'recording',
      name: storageName,
      uploader_id: uploaderId,
      url: filePath
    };
    const songColumnForInsert = audiosSongColumn || 'relational_song_id';
    insertPayload[songColumnForInsert] = currentSongIdResolved;

    const { error: insertError } = await supabase
      .from('audios')
      .insert(insertPayload);

    if (insertError) {
  console.error('Error saving the recording record:', insertError);
  setRecorderStatus('The recording was uploaded, but could not be saved in the database.', 'error');
      return;
    }

  setRecorderStatus('Recording uploaded successfully.', 'success');
    resetRecordingState({ keepInput: false, silent: true });
    loadAudios({ skipRealtimeSetup: true });
  } catch (err) {
  console.error('Unexpected error while uploading the recording:', err);
  setRecorderStatus('An error occurred while uploading the recording.', 'error');
  } finally {
    isUploadingRecording = false;
    updateRecorderUi();
  }
}

function initRecorderControls() {
  const elements = ensureRecorderElements();
  if (!elements || elements.initialized || !elements.toggleButton) return;
  elements.initialized = true;

  elements.toggleButton.addEventListener('click', (event) => {
    event.preventDefault();
    if (mediaRecorder && mediaRecorder.state === 'recording') {
      stopRecording();
    } else {
      startRecording();
    }
  });
  elements.uploadButton.addEventListener('click', (event) => {
    event.preventDefault();
    uploadRecording();
  });
  elements.discardButton.addEventListener('click', (event) => {
    event.preventDefault();
    discardRecording();
  });

  setDefaultRecorderStatus();
  updateRecorderUi();
}

function scheduleAudiosRefresh() {
  if (audiosRefreshTimeout) {
    clearTimeout(audiosRefreshTimeout);
  }
  audiosRefreshTimeout = setTimeout(() => {
    audiosRefreshTimeout = null;
    loadAudios({ skipRealtimeSetup: true });
  }, 150);
}

function isColumnMissingError(error) {
  if (!error) return false;
  const code = error.code || error?.details?.code;
  const message = String(error.message || error.details || '').toLowerCase();
  return code === '42703' || message.includes('column') && message.includes('does not exist');
}

async function fetchSongAudiosByCandidates(songId) {
  let lastError = null;
  for (const column of AUDIO_SONG_COLUMN_CANDIDATES) {
    try {
      const { data, error } = await supabase
        .from('audios')
        .select('id, instrument, url')
        .eq(column, songId)
        .order('instrument', { ascending: true });

      if (error) {
        if (isColumnMissingError(error)) {
          continue;
        }
        lastError = error;
        continue;
      }

      return { audios: data || [], columnUsed: column };
    } catch (err) {
      if (isColumnMissingError(err)) {
        continue;
      }
      lastError = err;
    }
  }

  return { audios: [], columnUsed: audiosSongColumn, error: lastError };
}

function initAudiosRealtime() {
  if (!currentSongIdResolved) return;

  if (audiosChannel) {
    supabase.removeChannel(audiosChannel);
    audiosChannel = null;
  }

  audiosChannel = supabase
    .channel(`audios_song_${currentSongIdResolved}`)
    .on('postgres_changes', {
      event: '*',
      schema: 'public',
      table: 'audios',
      filter: `${audiosSongColumn || 'relational_song_id'}=eq.${currentSongIdResolved}`
    }, scheduleAudiosRefresh);

  audiosChannel.subscribe((status) => {
    if (status === 'CHANNEL_ERROR') {
      console.error('Error suscribiéndose a cambios de audios en tiempo real');
    }
  });
}

function attachPlayback(button, audio, card, waveformElements) {
  if (!button) return;
  button.dataset.playing = 'false';
  button.addEventListener('click', (event) => {
    event.stopPropagation();
    expandCard(card);
    togglePlayback(button, audio, waveformElements);
  });
}

function initUploadFab() {
  const fab = document.getElementById('upload-audio-fab');
  const fileInput = document.getElementById('audio-file-input');

  if (!fab || !fileInput) return;

  fab.addEventListener('click', () => {
    fileInput.value = '';
    fileInput.click();
  });

  fileInput.addEventListener('change', (event) => {
    const file = event.target.files && event.target.files[0];
    if (!file) return;
    console.log('Archivo de audio seleccionado:', file.name, file.type, file.size);
    // TODO: manejar carga de audio y UI relacionada
  });
}

async function loadAudios(options = {}) {
  const { skipRealtimeSetup = false } = options;
  const headingEl = document.querySelector('h2');
  let headingTitle = title || '';
  let songId = songIdParam ? Number(songIdParam) : null;
  let songRecord = null;

  try {
    // Use probing helpers to resolve song record by id or title. This avoids
    // querying tables that may not exist in every schema (e.g., 'nombres_canciones').
    if (songId) {
      try {
        const probed = await fetchAndApplySongTitle(songId);
        if (probed) {
          songRecord = probed.raw || probed;
          songId = probed.id || songId;
          if (!headingTitle && probed.title) headingTitle = probed.title;
        } else {
          songId = null;
        }
      } catch (err) {
        console.error('Error obteniendo canción por ID:', err);
        songId = null;
      }
    }

    if (!songRecord && headingTitle) {
      try {
        const probed = await probeSongByTitle(headingTitle);
        if (probed) {
          songRecord = probed.raw || probed;
          songId = probed.id || songId;
          if (!headingTitle && probed.title) headingTitle = probed.title;
        }
      } catch (err) {
        console.error('Error obteniendo nombre de canción (probe):', err);
      }
    }

    if (!songRecord || !songId) {
      console.warn('No se encontró la canción para cargar audios.');
      setRecorderStatus('No se encontró la canción para grabar.', 'warning');
      updateRecorderUi();
      await refreshSongStatusUi(null);
      return;
    }

    if (headingEl && headingTitle) {
      headingEl.textContent = headingTitle;
    }

    const previousSongId = currentSongIdResolved;
    currentSongIdResolved = songId;
    setDefaultRecorderStatus();
    updateRecorderUi();
    await refreshSongStatusUi(songId);

    const { audios, columnUsed, error: audiosError } = await fetchSongAudiosByCandidates(songId);
    if (columnUsed) {
      audiosSongColumn = columnUsed;
    }
    if (audiosError) {
      console.error('Error obteniendo audios:', audiosError);
    }

    const container = document.querySelector('.space-y-4');
    container.innerHTML = '';

    if (!audios || audios.length === 0) {
      const emptyState = document.createElement('div');
      emptyState.className = 'rounded-lg bg-gray-800 p-6 text-center text-gray-400';
      emptyState.textContent = 'Aún no hay pistas registradas para esta canción.';
      container.appendChild(emptyState);
      clearPlaybackCache();
      updateRecorderUi();
      setDefaultRecorderStatus();

      if (!skipRealtimeSetup && (previousSongId !== currentSongIdResolved || !audiosChannel)) {
        initAudiosRealtime();
      }
      return;
    }

    clearPlaybackCache();

    audios.forEach((audio) => {
      const audioElement = document.createElement('div');
      audioElement.className = 'audio-card flex flex-col gap-4 rounded-lg bg-gray-800 p-4';
      audioElement.dataset.audioId = audio.id;
      audioElement.innerHTML = `
        <div class="audio-card__header">
          <p class="audio-card__title text-lg font-semibold text-white">${audio.instrument || 'Instrumento sin nombre'}</p>
          <div class="audio-card__controls" data-role="controls">
            <button type="button" class="flex items-center justify-center rounded-full bg-gray-700 text-white transition-colors hover:bg-gray-600" data-role="rewind-button" aria-label="Retroceder ${SEEK_OFFSET_SECONDS} segundos" title="Retroceder ${SEEK_OFFSET_SECONDS} segundos">
              <span class="material-symbols-outlined text-3xl">fast_rewind</span>
            </button>
            <button type="button" class="flex items-center justify-center rounded-full bg-[var(--primary-color)] text-white" data-role="play-button" aria-label="Reproducir o pausar" title="Reproducir o pausar">
              <span class="material-symbols-outlined text-4xl">play_arrow</span>
            </button>
            <button type="button" class="flex items-center justify-center rounded-full bg-gray-700 text-white transition-colors hover:bg-gray-600" data-role="forward-button" aria-label="Avanzar ${SEEK_OFFSET_SECONDS} segundos" title="Avanzar ${SEEK_OFFSET_SECONDS} segundos">
              <span class="material-symbols-outlined text-3xl">fast_forward</span>
            </button>
          </div>
        </div>
        <div class="waveform" data-role="waveform">
          <div class="waveform-viewport" data-role="waveform-viewport">
            <div class="waveform-content" data-role="waveform-content"></div>
          </div>
        </div>
      `;
      const playButton = audioElement.querySelector('[data-role="play-button"]');
      const rewindButton = audioElement.querySelector('[data-role="rewind-button"]');
      const forwardButton = audioElement.querySelector('[data-role="forward-button"]');
      const waveformViewport = audioElement.querySelector('[data-role="waveform-viewport"]');
      const waveformContent = audioElement.querySelector('[data-role="waveform-content"]');
      buildWaveformState({ viewportEl: waveformViewport, contentEl: waveformContent }, audio.id);
      attachPlayback(playButton, audio, audioElement, { viewportEl: waveformViewport, contentEl: waveformContent });
      attachSeekControl(rewindButton, audio, audioElement, -SEEK_OFFSET_SECONDS, { viewportEl: waveformViewport, contentEl: waveformContent });
      attachSeekControl(forwardButton, audio, audioElement, SEEK_OFFSET_SECONDS, { viewportEl: waveformViewport, contentEl: waveformContent });
      prepareAudioPlayer(audio, null, { viewportEl: waveformViewport, contentEl: waveformContent })
        .catch((err) => {
          console.debug('No se pudo preparar la forma de onda para el audio', audio.id, err?.message || err);
        });
      audioElement.addEventListener('click', (event) => {
        if (event.target.closest('[data-role="play-button"], [data-role="rewind-button"], [data-role="forward-button"], .audio-card__controls')) return;
        if (currentExpandedCard === audioElement) {
          collapseCurrentCard();
          return;
        }
        expandCard(audioElement);
      });
      container.appendChild(audioElement);
    });
    setDefaultRecorderStatus();
    updateRecorderUi();

    if (!skipRealtimeSetup && (previousSongId !== currentSongIdResolved || !audiosChannel)) {
      initAudiosRealtime();
    }
  } catch (err) {
    console.error('Error general al cargar audios:', err);
    setRecorderStatus('Ocurrió un error al cargar las pistas.', 'error');
    updateRecorderUi();
  }
}

initSongStatusControls();
initRecorderControls();
loadAudios();
initUploadFab();

window.addEventListener('resize', () => {
  playbackCache.forEach((cacheEntry) => {
    if (!cacheEntry || !cacheEntry.waveform) return;
    refreshWaveformMetrics(cacheEntry.waveform);
    const currentTime = cacheEntry.waveform.lastCurrentTime ?? cacheEntry.player?.currentTime ?? 0;
    const duration = cacheEntry.waveform.duration ?? cacheEntry.player?.duration ?? 0;
    applyWaveformPosition(cacheEntry.waveform, currentTime, duration);
  });
});

window.addEventListener('beforeunload', () => {
  clearPlaybackCache();
  if (audiosChannel) {
    supabase.removeChannel(audiosChannel);
    audiosChannel = null;
  }
});
</script>

</body></html>