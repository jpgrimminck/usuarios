

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE TYPE "public"."status_tag" AS ENUM (
    '1',
    '2',
    '3'
);


ALTER TYPE "public"."status_tag" OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."artists" (
    "id" integer NOT NULL,
    "name" "text" NOT NULL,
    "note" "text"
);


ALTER TABLE "public"."artists" OWNER TO "postgres";


COMMENT ON COLUMN "public"."artists"."note" IS 'a simple text to make a difference with another same artist';



ALTER TABLE "public"."artists" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."artistas_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."audios" (
    "id" integer NOT NULL,
    "name" "text" NOT NULL,
    "detail" "text" NOT NULL,
    "uploader_id" integer NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "url" "text",
    "relational_song_id" integer NOT NULL,
    "is_private" boolean DEFAULT false NOT NULL
);

ALTER TABLE ONLY "public"."audios" REPLICA IDENTITY FULL;


ALTER TABLE "public"."audios" OWNER TO "postgres";


ALTER TABLE "public"."audios" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."audios_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."missions" (
    "number" bigint NOT NULL,
    "title" "text" DEFAULT 'Misiones'::"text" NOT NULL,
    "stars" smallint DEFAULT '0'::smallint,
    "status" boolean DEFAULT false,
    "student" "text"
);


ALTER TABLE "public"."missions" OWNER TO "postgres";


ALTER TABLE "public"."missions" ALTER COLUMN "number" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."missions_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."songs" (
    "id" integer NOT NULL,
    "title" "text" NOT NULL,
    "created_by" integer,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "artist_id" integer
);


ALTER TABLE "public"."songs" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."songs_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."songs_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."songs_id_seq" OWNED BY "public"."songs"."id";



CREATE TABLE IF NOT EXISTS "public"."user_ip" (
    "id" integer NOT NULL,
    "ip" "text" NOT NULL,
    "selected_user_id" integer,
    "created_at" timestamp with time zone,
    "device_type" "text",
    "screen_format" "text",
    "resolution" "text",
    "ppi" integer,
    "os" "text",
    "location" "text",
    "language" "text",
    "timezone" "text",
    "browser" "text",
    "browser_version" "text",
    "os_version" "text",
    "device_model" "text",
    "user_agent" "text",
    "internet_connection" "text",
    "ram" "text",
    "cores" integer,
    "dark_mode" boolean,
    "notch" boolean,
    "supports_touch" boolean,
    "inner_width" integer,
    "inner_height" integer,
    "latency" integer,
    "approved" boolean DEFAULT false,
    "email" character varying,
    CONSTRAINT "user_ip_email_check" CHECK ((("email")::"text" ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'::"text"))
);


ALTER TABLE "public"."user_ip" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."user_ip_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."user_ip_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."user_ip_id_seq" OWNED BY "public"."user_ip"."id";



CREATE TABLE IF NOT EXISTS "public"."user_meta" (
    "student" "text" NOT NULL,
    "objective" "text" NOT NULL,
    "selected_mission" smallint,
    "updated_at" timestamp with time zone
);


ALTER TABLE "public"."user_meta" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_songs" (
    "user_id" integer NOT NULL,
    "song_id" integer NOT NULL,
    "added_at" timestamp with time zone DEFAULT "now"(),
    "status_tag" "public"."status_tag" DEFAULT '1'::"public"."status_tag" NOT NULL
);

ALTER TABLE ONLY "public"."user_songs" REPLICA IDENTITY FULL;


ALTER TABLE "public"."user_songs" OWNER TO "postgres";


COMMENT ON TABLE "public"."user_songs" IS 'Which songs does the user have in their account';



CREATE TABLE IF NOT EXISTS "public"."users" (
    "id" integer NOT NULL,
    "name" "text" NOT NULL,
    "created_at" timestamp without time zone DEFAULT "now"(),
    "is_admin" boolean DEFAULT false,
    "Parental Control" boolean DEFAULT true,
    "email" character varying,
    "role" character varying DEFAULT 'user'::character varying,
    CONSTRAINT "users_email_check" CHECK ((("email")::"text" ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'::"text")),
    CONSTRAINT "users_role_check" CHECK ((("role")::"text" = ANY ((ARRAY['user'::character varying, 'parent'::character varying, 'admin'::character varying])::"text"[])))
);


ALTER TABLE "public"."users" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."users_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."users_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."users_id_seq" OWNED BY "public"."users"."id";



ALTER TABLE ONLY "public"."songs" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."songs_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."user_ip" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."user_ip_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."users" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."users_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."artists"
    ADD CONSTRAINT "artistas_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."audios"
    ADD CONSTRAINT "audios_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."missions"
    ADD CONSTRAINT "missions_pkey" PRIMARY KEY ("number");



ALTER TABLE ONLY "public"."songs"
    ADD CONSTRAINT "songs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_ip"
    ADD CONSTRAINT "user_ip_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_meta"
    ADD CONSTRAINT "user_meta_pkey" PRIMARY KEY ("student");



ALTER TABLE ONLY "public"."user_songs"
    ADD CONSTRAINT "user_songs_pkey" PRIMARY KEY ("user_id", "song_id");



ALTER TABLE ONLY "public"."user_songs"
    ADD CONSTRAINT "user_songs_user_id_song_id_key" UNIQUE ("user_id", "song_id");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_pkey" PRIMARY KEY ("id");



CREATE INDEX "ix_audios_uploader" ON "public"."audios" USING "btree" ("uploader_id");



ALTER TABLE ONLY "public"."audios"
    ADD CONSTRAINT "audios_relational_song_id_fkey" FOREIGN KEY ("relational_song_id") REFERENCES "public"."songs"("id");



ALTER TABLE ONLY "public"."audios"
    ADD CONSTRAINT "audios_uploader_id_fkey" FOREIGN KEY ("uploader_id") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."songs"
    ADD CONSTRAINT "songs_artist_id_fkey" FOREIGN KEY ("artist_id") REFERENCES "public"."artists"("id");



ALTER TABLE ONLY "public"."songs"
    ADD CONSTRAINT "songs_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."user_ip"
    ADD CONSTRAINT "user_ip_selected_user_id_fkey" FOREIGN KEY ("selected_user_id") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."user_songs"
    ADD CONSTRAINT "user_songs_song_id_fkey" FOREIGN KEY ("song_id") REFERENCES "public"."songs"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_songs"
    ADD CONSTRAINT "user_songs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;





ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";






ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."artists";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."audios";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."missions";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."songs";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."user_ip";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."user_meta";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."user_songs";



GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";








































































































































































GRANT ALL ON TABLE "public"."artists" TO "anon";
GRANT ALL ON TABLE "public"."artists" TO "authenticated";
GRANT ALL ON TABLE "public"."artists" TO "service_role";



GRANT ALL ON SEQUENCE "public"."artistas_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."artistas_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."artistas_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."audios" TO "anon";
GRANT ALL ON TABLE "public"."audios" TO "authenticated";
GRANT ALL ON TABLE "public"."audios" TO "service_role";



GRANT ALL ON SEQUENCE "public"."audios_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."audios_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."audios_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."missions" TO "anon";
GRANT ALL ON TABLE "public"."missions" TO "authenticated";
GRANT ALL ON TABLE "public"."missions" TO "service_role";



GRANT ALL ON SEQUENCE "public"."missions_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."missions_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."missions_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."songs" TO "anon";
GRANT ALL ON TABLE "public"."songs" TO "authenticated";
GRANT ALL ON TABLE "public"."songs" TO "service_role";



GRANT ALL ON SEQUENCE "public"."songs_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."songs_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."songs_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."user_ip" TO "anon";
GRANT ALL ON TABLE "public"."user_ip" TO "authenticated";
GRANT ALL ON TABLE "public"."user_ip" TO "service_role";



GRANT ALL ON SEQUENCE "public"."user_ip_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."user_ip_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."user_ip_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."user_meta" TO "anon";
GRANT ALL ON TABLE "public"."user_meta" TO "authenticated";
GRANT ALL ON TABLE "public"."user_meta" TO "service_role";



GRANT ALL ON TABLE "public"."user_songs" TO "anon";
GRANT ALL ON TABLE "public"."user_songs" TO "authenticated";
GRANT ALL ON TABLE "public"."user_songs" TO "service_role";



GRANT ALL ON TABLE "public"."users" TO "anon";
GRANT ALL ON TABLE "public"."users" TO "authenticated";
GRANT ALL ON TABLE "public"."users" TO "service_role";



GRANT ALL ON SEQUENCE "public"."users_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."users_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."users_id_seq" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";






























drop extension if exists "pg_net";

alter table "public"."users" drop constraint "users_role_check";

alter table "public"."users" add constraint "users_role_check" CHECK (((role)::text = ANY ((ARRAY['user'::character varying, 'parent'::character varying, 'admin'::character varying])::text[]))) not valid;

alter table "public"."users" validate constraint "users_role_check";


  create policy "Allow anon deletes 1brjcyl_0"
  on "storage"."objects"
  as permissive
  for delete
  to anon
using ((bucket_id = 'audios'::text));



  create policy "Allow anon uploads"
  on "storage"."objects"
  as permissive
  for insert
  to anon
with check ((bucket_id = 'audios'::text));



  create policy "allow anon select 1brjcyl_0"
  on "storage"."objects"
  as permissive
  for select
  to anon
using ((bucket_id = 'audios'::text));



